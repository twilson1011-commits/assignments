Compare array-based vs list-based implementations of stacks and queues:

memory layout
Array - stored in contiguous memory and allocated one by one 
List - stored in nodes in non contiguous memory 
resizing behavior
Array - a fixed capacity need to hard code a size 
List - no hard coded size self expanding when necessary 
cache friendliness (Yes, cache friendliness matters. No, you may not ignore it.)
	Array - very friendly because of contiguous memory 
	List - bad friendliness nodes and pointers are complex 

Why is std::vector a natural fit for a stack, but awkward for a queue?
A vector is a type of array without a hard coded size but, it has a list of elements which makes stacks a good fit while the queue needs to shift elements around. 

Define the invariant for:


a stack
 The next element removed is the most recently inserted element that hasn’t been removed yet. (LIFO)

a queue
The next element removed is the earliest inserted element that hasn’t been removed yet. (FIFO)
Fill out the table:
Feature
Overloading
Overriding
Resolved at
Compiling 
runtime
Requires inheritance
no
yes
Same function name
yes
yes
Same parameter list
no
yes
Polymorphism involved
no
yes

Then answer:
Why is overloading a compile-time convenience?
The compiler chooses which version to call at compile time based purely on the argument types.
Why is overriding a runtime contract?
Because of polymorphism 
Why do beginners confuse the two?
They look very similar 
Why is that confusion dangerous?
The code won’t work and code have memory leaks or problems 
Given:
class Widget {
private:
    const int id;
    std::string name;

public:
    Widget(int id, std::string name);
};
Answer:
Why must this constructor use an initialization list?
Const must be initialized  
What happens if you try to assign id inside the constructor body?
Id cant be made while the code is running its a const 
Write the correct constructor.
#include <iostream>


using namespace std;


class Widget{
    string name;
    int id;


public:


//Widget (){}


    string getName(){
        return name;
    }
    int getId(){
        return id;
    }
    void setName(string name){
        this->name=name;
    }
    void setId(int id){
        this->id = id;
    }


    friend ostream& operator<< (const ostream& apple,const Widget& other){
        return apple << other.name <<","<< other.id <<endl;


    }
   
};


int main(){
    Widget w1;
    cout << w1 << endl;
    w.setName("Bannana");
    w.setId(99);
    cout<<w.getId()<<endl;
       
    Widget w2 = w1;
    cout << w2 << endl;
    return 0;


}

Name one other situation where initialization lists are required (research-lite).
Members of a class with no default constructor
Research + reasoning required.
When is the copy constructor invoked?
The copy constructor is called when a new object is being created from an existing object.
When is the assignment operator invoked?
The assignment operator is called when an already existing object is assigned a new value from another object
Why do both exist?
Because construction and assignment are very different operations.
What subtle bugs appear if you confuse them?
Both objects can point to the same memory, the program can crash, and wrong values are being assigned 
Answer:
What is the only language-level difference between struct and class?
The default access specifiers 
Why does C++ even allow both?
To allow older codes to still work 
When does choosing struct communicate intent better than class?
When you are defining simple data or data dumping 
Why does intent matter more than syntax in large systems?
Struct does not hide data while class has private 

 Research and explain:
Why can’t C++ overload:


.
The . access things specifically It’s a fundamental compile-time operation: the compiler needs to know the type of the object to resolve which member is being accessed.Allowing overloads would break type safety and static resolution, because at compile time it must know what the expression means.
::
:: resolves names in a namespace or class. Name resolution happens entirely at compile time, not runtime. Overloading it would require runtime semantics for something fundamentally static, which violates the language design.
sizeof
sizeof is evaluated entirely at compile time for type or object size. Overloading it would imply it could produce a dynamic size, breaking the core memory model.
Why should operator+ not mutate the left-hand operand?
operator+ is conceptually arithmetic or combination → should produce a new object.
Predictability: Users expect + to be non-destructive.
Consistency: Built-in types (int, double) don’t mutate operands. 
Safety: Mutation can lead to subtle bugs if a value is reused:


Why is operator<< almost never a member function?
The operator<< is almost never a member function because it requires the left-hand operand to be an instance of std::ostream (like std::cout), which is a fixed standard library class that cannot be modified to add custom member functions. To use << with custom types, the operator must be a non-member (typically a friend) function, as the left operand is not the user-defined class itself.
Given:

Point operator+(const Point& rhs) const;

Answer clearly:

    Which object owns this function?
A member function of the point class
    What does rhs represent?
It's the Right Hand Side of what's being added like A+B rhs is B.
    How can this function access rhs.x if x is private?
The rhs function belongs to point so it can access the private section 
    What does this tell you about class-level vs object-level access?
Class level - Private/protected members are enforced per class, not per object
Object-level access is restricted only by the class rules, not by the particular instance.
Answer:
What does the friend keyword actually do?
friend grants a non-member function or another class access to the private and protected members of your class
Why is operator<< commonly declared as a friend?
allows direct access to private members while keeping operator<< as a non-member function, preserving the intuitive ostream << object syntax.
Why is excessive use of friend a red flag?
If nothing is working correctly you shouldn't need Friend you don't put a bandaid on a dead person 
Give one legitimate use case and one illegitimate one.
Good one - friend std::ostream& operator<<(std::ostream&, const MyClass&);
Bad one - friend void externalFunction(MyClass& obj) { obj.x += 10; }

You are designing a type, not checking boxes.
Required Features
Your Point2D class must:
Use private data members
Include at least three constructors:
default
parameterized
copy constructor
Use initialization lists
Overload:
+
-
==
!= (without duplicating logic)
<<
Demonstrate const correctness
Avoid public getters unless you can justify them
Required Usage (This Must Compile)
Point2D a(3, 4);
Point2D b(1, 2);

Point2D c = a + b;
Point2D d = a - b;

if (c == Point2D(4, 6)) {
    std::cout << "Math still works.\n";
}

std::cout << a << std::endl;
Answer honestly:
Does your Point2D feel like a built-in type?
I think so because no get functions are used and everything is in public and works.
What design choice most contributed to that feeling?
overloading the “operator” and the program working as intended.
Which OOP concept currently feels overhyped?
Vectors you explained them for the first time to us in class so they seem like a easier version of an array. 
Which one feels underrated?
Also Vectors which is ironic but our previous instructors have forbidden the use of them so they feel like a cheat we are not allowed to use.
What part of this worksheet made you uncomfortable — and why?
The incredibly broad nature of the assignment the questions were not exact and most of us are drowning in new information, programming concepts and syntax we have never seen before. 



